<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixBattle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #c4c4c4;
            font-family: Arial, sans-serif;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: none;
        }
        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        .button {
            position: fixed;
            padding: 8px 16px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            user-select: none;
        }
        .button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #clearButton {
            top: 20px;
            left: 20px;
        }
        #toggleGridButton {
            top: 20px;
            left: 120px;
        }
        #downloadButton {
            top: 20px;
            left: 220px;
        }
        .cursor {
            position: fixed;
            pointer-events: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            z-index: 1000;
            mix-blend-mode: difference;
        }
        .cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        @keyframes pixelPlace {
            0% {
                transform: scale(1.5);
                opacity: 0;
            }
            50% {
                transform: scale(0.8);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        @keyframes pixelHover {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>
    <div class="cursor"></div>
    <button id="clearButton" class="button">Очистити</button>
    <button id="toggleGridButton" class="button">Сітка</button>
    <button id="downloadButton" class="button">Зберегти</button>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script>
        const GRID_SIZE = 128;
        const PIXEL_SIZE = 5;
        const MIN_SCALE = 0.5;
        const MAX_SCALE = 10;
        const SCALE_SPEED = 0.001;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const cursor = document.querySelector('.cursor');

        minimapCanvas.width = GRID_SIZE;
        minimapCanvas.height = GRID_SIZE;

        let pixels = {};
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let showGrid = true;
        let selectedColor = '#000000';

        canvas.width = GRID_SIZE * PIXEL_SIZE;
        canvas.height = GRID_SIZE * PIXEL_SIZE;

        const socket = io({
            path: '/socket.io',
            transports: ['websocket'],
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            alert('Помилка підключення. Будь ласка, оновіть сторінку.');
        });

        socket.on('pixels', (data) => {
            pixels = data;
            draw();
        });

        socket.on('pixel', (data) => {
            pixels[data.index] = data.color;
            draw();
            
            // Анімація появи пікселя
            const x = data.index % GRID_SIZE;
            const y = Math.floor(data.index / GRID_SIZE);
            const pixelX = x * PIXEL_SIZE * scale + offsetX;
            const pixelY = y * PIXEL_SIZE * scale + offsetY;
            
            ctx.save();
            ctx.translate(pixelX + PIXEL_SIZE * scale / 2, pixelY + PIXEL_SIZE * scale / 2);
            ctx.fillStyle = data.color;
            ctx.beginPath();
            ctx.rect(-PIXEL_SIZE * scale / 2, -PIXEL_SIZE * scale / 2, PIXEL_SIZE * scale, PIXEL_SIZE * scale);
            ctx.fill();
            ctx.restore();
            
            // Анімація
            const pixel = document.createElement('div');
            pixel.style.position = 'absolute';
            pixel.style.left = pixelX + 'px';
            pixel.style.top = pixelY + 'px';
            pixel.style.width = PIXEL_SIZE * scale + 'px';
            pixel.style.height = PIXEL_SIZE * scale + 'px';
            pixel.style.backgroundColor = data.color;
            pixel.style.animation = 'pixelPlace 0.3s ease-out';
            pixel.style.pointerEvents = 'none';
            document.body.appendChild(pixel);
            
            setTimeout(() => {
                document.body.removeChild(pixel);
            }, 300);
        });

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Малюємо пікселі
            Object.entries(pixels).forEach(([index, color]) => {
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                ctx.fillStyle = color;
                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            });

            // Малюємо сітку
            if (showGrid) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 0.5 / scale;
                
                for (let i = 0; i <= GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * PIXEL_SIZE, 0);
                    ctx.lineTo(i * PIXEL_SIZE, GRID_SIZE * PIXEL_SIZE);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, i * PIXEL_SIZE);
                    ctx.lineTo(GRID_SIZE * PIXEL_SIZE, i * PIXEL_SIZE);
                    ctx.stroke();
                }
            }

            ctx.restore();
            updateMinimap();
        }

        function updateMinimap() {
            minimapCtx.clearRect(0, 0, GRID_SIZE, GRID_SIZE);
            
            // Малюємо пікселі на мініатюрі
            Object.entries(pixels).forEach(([index, color]) => {
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                minimapCtx.fillStyle = color;
                minimapCtx.fillRect(x, y, 1, 1);
            });
            
            // Показуємо поточну видиму область
            const viewportRect = {
                x: -offsetX / (PIXEL_SIZE * scale),
                y: -offsetY / (PIXEL_SIZE * scale),
                width: canvas.width / (PIXEL_SIZE * scale),
                height: canvas.height / (PIXEL_SIZE * scale)
            };
            
            minimapCtx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
            minimapCtx.strokeRect(
                viewportRect.x,
                viewportRect.y,
                viewportRect.width,
                viewportRect.height
            );
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const oldScale = scale;
            scale *= Math.pow(2, -e.deltaY * SCALE_SPEED);
            scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));

            offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
            offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);

            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Оновлюємо позицію курсора
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';

            if (isDragging) {
                offsetX += e.clientX - lastX;
                offsetY += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            }

            // Координати пікселя під курсором
            const x = Math.floor((mouseX - offsetX) / (PIXEL_SIZE * scale));
            const y = Math.floor((mouseY - offsetY) / (PIXEL_SIZE * scale));

            // Анімація наведення на піксель
            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                const index = y * GRID_SIZE + x;
                const pixelX = x * PIXEL_SIZE * scale + offsetX;
                const pixelY = y * PIXEL_SIZE * scale + offsetY;
                
                cursor.style.width = (PIXEL_SIZE * scale) + 'px';
                cursor.style.height = (PIXEL_SIZE * scale) + 'px';
                cursor.style.borderRadius = '0';
                cursor.style.animation = 'pixelHover 1s ease-in-out infinite';
            } else {
                cursor.style.width = '20px';
                cursor.style.height = '20px';
                cursor.style.borderRadius = '50%';
                cursor.style.animation = 'none';
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const x = Math.floor((mouseX - offsetX) / (PIXEL_SIZE * scale));
            const y = Math.floor((mouseY - offsetY) / (PIXEL_SIZE * scale));

            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                const index = y * GRID_SIZE + x;
                socket.emit('pixel', { index, color: selectedColor });
            }
        });

        document.getElementById('clearButton').addEventListener('click', () => {
            socket.emit('clear');
        });

        document.getElementById('toggleGridButton').addEventListener('click', () => {
            showGrid = !showGrid;
            draw();
        });

        document.getElementById('downloadButton').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'pixbattle.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        // Початкове відображення
        draw();
    </script>
</body>
</html>