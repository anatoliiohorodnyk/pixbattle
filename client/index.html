<!DOCTYPE html>
<html>
<head>
    <title>PixBattle</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial; }
        .container { display: flex; }
        .sidebar { width: 200px; margin-right: 20px; }
        #canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <input type="color" id="colorPicker" value="#000000">
            <div>Online: <span id="onlineCount">0</span></div>
            <div>Your pixels: <span id="userPixels">0</span></div>
            <div>Position: <span id="cursorPos">0, 0</span></div>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const PIXEL_SIZE = 16;
            const GRID_SIZE = 64;

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const colorPicker = document.getElementById('colorPicker');
            const cursorPos = document.getElementById('cursorPos');
            const onlineCount = document.getElementById('onlineCount');
            const userPixels = document.getElementById('userPixels');

            canvas.width = PIXEL_SIZE * GRID_SIZE;
            canvas.height = PIXEL_SIZE * GRID_SIZE;

            let pixels = {};
            let userPixelCount = 0;

            const socket = io(window.location.origin, {
                transports: ['websocket']
            });

            socket.on('connect', () => console.log('Connected'));
            socket.on('connect_error', (error) => console.error('Connection error:', error));

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                Object.entries(pixels).forEach(([index, color]) => {
                    const x = (index % GRID_SIZE) * PIXEL_SIZE;
                    const y = Math.floor(index / GRID_SIZE) * PIXEL_SIZE;
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, PIXEL_SIZE, PIXEL_SIZE);
                });

                ctx.strokeStyle = '#eee';
                for(let i = 0; i <= GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * PIXEL_SIZE, 0);
                    ctx.lineTo(i * PIXEL_SIZE, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * PIXEL_SIZE);
                    ctx.lineTo(canvas.width, i * PIXEL_SIZE);
                    ctx.stroke();
                }
            }

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
                socket.emit('updatePixel', {
                    index: y * GRID_SIZE + x,
                    color: colorPicker.value
                });
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
                cursorPos.textContent = `${x}, ${y}`;
            });

            socket.on('init', (initialPixels) => {
                pixels = initialPixels;
                draw();
            });

            socket.on('pixelUpdated', (data) => {
                pixels[data.index] = data.color;
                if (data.userId === socket.id) {
                    userPixelCount++;
                    userPixels.textContent = userPixelCount;
                }
                draw();
            });

            socket.on('usersCount', (count) => {
                onlineCount.textContent = count;
            });
        });
    </script>
</body>
</html>